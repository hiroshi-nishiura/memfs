#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
  Simple On Memory File System Creator
"""
import sys
import argparse
from pathlib import Path

# table format: file:[next, pos, size, name] dir:[next, num, 0, name]


def out_header(out, table, name):
    out.write('/* This file is generated by the MEMFS Converter */\n')
    out.write('#ifndef _MEMFS_{}_H_\n'.format(name))
    out.write('#define _MEMFS_{}_H_\n'.format(name))
    out.write('\n')
    out.write('#ifdef __cplusplus\n')
    out.write('extern "C" {\n')
    out.write('#endif\n')
    out.write('\n')
    out.write('#include "memfs.h"\n')
    out.write('\n')
    out.write('extern const m_table ' + name + '_table[];\n')
    out.write('extern const uint8_t ' + name + '_data[];\n')
    out.write('extern const uint8_t ' + '_binary_' + name +
              '_data_bin_start[];\n')
    out.write('\n')
    out.write('#ifdef MEMFS_IMPLEMENTATION\n')
    out.write('\n')
    out.write('const m_table ' + name + '_table[]={\n')
    for i, t in enumerate(table):
        out.write('  {')
        out.write('{0},\t{1},\t{2},\t"{3}"'.format(t[0], t[1], t[2], t[3]))
        out.write('}, // ' + str(i) + '\n')
        i += 1
    out.write('};\n')
    out.write('#endif //MEMFS_IMPLEMENTATION\n')
    out.write('#ifdef __cplusplus\n')
    out.write('} // extern "C"\n')
    out.write('#endif\n')
    out.write('#endif //_MEMFS_{}_H_\n'.format(name))


def create_table(table, path, offs):
    for k in path.keys():
        offs += 1
        pos = len(table)
        if type(path[k]) is dict:
            offs = create_table(table, path[k], offs)
            table.insert(pos, [offs + 1, len(path[k]), 0, k])
        else:
            table.insert(pos, [offs + 1, path[k][0], path[k][1], k])
    return offs


def out_data_c(out, path, offs):
    for k in path.keys():
        if type(path[k]) is dict:
            offs = out_data_c(out, path[k], offs)
        else:
            name = str(path[k].relative_to(path[k].root))
            print(name, '... ', end='', flush=True)
            out.write('\n/* ' + name + ' */\n')
            size = 0
            for c in path[k].read_bytes():
                out.write(hex(c) + ',')
                size += 1
                if (size % 16) == 0: out.write('\n')

            print(hex(offs), size)
            path[k] = [offs, size]
            offs += size

            # 64bit padding
            padding = offs % 8
            if padding > 0:
                padding = 8 - padding
                out.write('0,' * padding)
                offs += padding
    return offs


def out_data_bin(out, path, offs):
    for k in path.keys():
        if type(path[k]) is dict:
            offs = out_data_bin(out, path[k], offs)
        else:
            name = str(path[k].relative_to(path[k].root))
            print(name, '... ', end='', flush=True)
            out.write(path[k].read_bytes())
            size = path[k].stat().st_size

            print(hex(offs), size)
            path[k] = [offs, size]
            offs += size

            # 64bit padding
            padding = offs % 8
            if padding > 0:
                padding = 8 - padding
                out.write(bytearray([0] * padding))
                offs += padding
    return offs


def traverse(path, dir):
    fs = {}
    files = sorted(dir.iterdir())
    if len(files) == 0: return  # ignore empty dir

    for f in files:
        if f.is_dir():
            traverse(fs, f)
        elif f.stat().st_size > 0:  # ignore empty file
            fs[f.name] = f
    path[dir.name] = fs


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Simple OnMemory File System Creator')
    parser.add_argument('-d',
                        action='append',
                        help='dir path ("." is not allowed)')
    parser.add_argument('-f', action='append', help='file path')
    parser.add_argument('-o', help='memfs name', default='memfs')
    parser.add_argument('-c',
                        action='store_true',
                        help='output as .c source code')
    args = parser.parse_args()
    if args.d == None and args.f == None:
        parser.print_help()
        sys.exit()

    print(args.c)

    if args.c:
        c_file = Path(args.o + '_data.c')
        if c_file.exists(): c_file.unlink()
        print('generate', c_file.name)
    else:
        bin_file = Path(args.o + '_data.bin')
        if bin_file.exists(): bin_file.unlink()
        print('generate', bin_file.name)

    h_file = Path(args.o + '_table.h')
    if h_file.exists(): h_file.unlink()

    root = {}
    if args.d:
        for dir in sorted(args.d):
            if dir == '.':
                print('"." is not allowed')
                sys.exit(-1)

            p = Path(dir)
            if p.is_dir():
                traverse(root, p)
            else:
                print('dir not found:', dir)
                sys.exit(-1)

    if args.f:
        for file in sorted(args.f):
            p = Path(file)
            if p.is_file():
                root[p.name] = p
            else:
                print('file not found:', file)
                sys.exit(-1)

    if args.c:
        out = c_file.open('w')
        out.write('/* This file is generated by the MEMFS Converter */\n')
        out.write('#include <stdint.h>\n')
        out.write('const uint8_t ' + args.o + '_data[]={')
        out_data_c(out, root, 0)
        out.write('};\n')
        out.close()
    else:
        out = bin_file.open('wb')
        out_data_bin(out, root, 0)
        out.close()

    table = []
    create_table(table, root, 0)
    # add root
    num = 0
    if args.d: num = len(args.d)
    if args.f: num += len(args.f)
    table.insert(0, [table[-1][0], num, 0, '.'])

    out = h_file.open('w')
    out_header(out, table, args.o)
    out.close()
